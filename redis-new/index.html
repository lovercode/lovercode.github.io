<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans,en,default"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="redis实现,listpack,线程池,多线程,可靠性,主从,哨兵,"><link rel="alternate" href="/atom.xml" title="go后端" type="application/atom+xml"><meta name="description" content="基本数据结构所有的底层数据结构都被包装成一个redisObject1234567typedef struct redisObject &amp;#123;    unsigned type:4;    unsigned encoding:4;    unsigned lru:LRU_BITS;     int refcount;    void *ptr; &#x2F;&#x2F; 指向真正的数据&amp;#125; robj;支持"><meta property="og:type" content="article"><meta property="og:title" content="redis详解"><meta property="og:url" content="https://codeloverme.cn/redis-new/index.html"><meta property="og:site_name" content="go后端"><meta property="og:description" content="基本数据结构所有的底层数据结构都被包装成一个redisObject1234567typedef struct redisObject &amp;#123;    unsigned type:4;    unsigned encoding:4;    unsigned lru:LRU_BITS;     int refcount;    void *ptr; &#x2F;&#x2F; 指向真正的数据&amp;#125; robj;支持"><meta property="article:published_time" content="2023-02-16T14:34:19.000Z"><meta property="article:modified_time" content="2023-02-21T16:09:47.146Z"><meta property="article:author" content="codelover"><meta property="article:tag" content="redis实现"><meta property="article:tag" content="listpack"><meta property="article:tag" content="线程池"><meta property="article:tag" content="多线程"><meta property="article:tag" content="可靠性"><meta property="article:tag" content="主从"><meta property="article:tag" content="哨兵"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://codeloverme.cn/redis-new/"><title>redis详解 | go后端</title><script async>!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="https://www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-161863329-1","auto"),ga("send","pageview")</script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/assets/css/APlayer.min.css" class="aplayer-style-marker">
<script src="/assets/js/APlayer.min.js" class="aplayer-script-marker"></script>
<script src="/assets/js/Meting.min.js" class="meting-script-marker"></script>
</head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">go后端</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个不会写c++的程序员不是一个好的go攻城狮</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block" width="100px"><link itemprop="mainEntityOfPage" href="https://codeloverme.cn/redis-new/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="codelover"><meta itemprop="description" content=""><meta itemprop="image" content="/images/logo.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="go后端"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">redis详解</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-02-16T22:34:19+08:00">2023-02-16 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span> </a></span></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5.4k </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">20</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><ul><li>所有的底层数据结构都被包装成一个redisObject<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; </span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 指向真正的数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></li></ul><h2 id="支持的数据结构"><a href="#支持的数据结构" class="headerlink" title="支持的数据结构"></a>支持的数据结构</h2><table><thead><tr><th>支持的数据结构</th><th>底层原理</th><th>备注</th><th>常用场景</th></tr></thead><tbody><tr><td>string</td><td><code>int</code><br><code>raw</code><br><code>embstr</code></td><td>二机制安全</td><td>kv缓存，分布式锁，计数器，限流器等</td></tr><tr><td>list</td><td><code>linklist</code>(废弃)<br><code>ziplist</code>(废弃)<br><code>quicklist</code><br><code>listpack</code></td><td>redis7.0中list的底层是quicklist</td><td>队列，栈，mq</td></tr><tr><td>set</td><td><code>intset</code><br><code>lishpack</code><br><code>hashtable</code></td><td>集合</td><td>求交差并集，去重</td></tr><tr><td>sortset</td><td><code>skiplist+hashtable</code><br><code>listpack</code></td><td>有序集合</td><td>排行榜，关系链，分层排序</td></tr><tr><td>hash</td><td><code>listpack</code><br><code>hashtable</code></td><td>hash表</td><td>去重，保存对象信息</td></tr><tr><td>bitmap</td><td><code>string</code></td><td>利用strign对象实现的</td><td>去重，统计，签到</td></tr><tr><td>hyperloglog</td><td><code>string</code></td><td>利用strign对象实现的</td><td>统计uv，计算去重的个数</td></tr><tr><td>geospatial</td><td><code>sortset</code></td><td>geohash编码地理位置，zset存储最后编码的数据，相邻分数距离更近</td><td>统计附近的人等</td></tr></tbody></table><h2 id="string的三种编码方式"><a href="#string的三种编码方式" class="headerlink" title="string的三种编码方式"></a>string的三种编码方式</h2><ul><li>为了节省内存，redis的string对象有三种编码方式</li></ul><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><ul><li><code>ptr</code>字段直接保存成<code>int</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│   <span class="built_in"> type </span>    │</span><br><span class="line">│ OBJ_STRING  │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   encoding  │</span><br><span class="line">│     int     │</span><br><span class="line">├─────────────┤</span><br><span class="line">│     lru     │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   refcount  │</span><br><span class="line">├─────────────┤</span><br><span class="line">│     ptr     ├────► 123</span><br><span class="line">└─────────────┘</span><br></pre></td></tr></table></figure><h3 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h3><ul><li><code>ptr</code>指向一个sds结构体</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│    <span class="built_in"> type </span>   │</span><br><span class="line">│  OBJ_STRING │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   encoding  │     ┌─────────┐</span><br><span class="line">│    <span class="built_in"> raw </span>    │     │   len   │</span><br><span class="line">├─────────────┤     ├─────────┤</span><br><span class="line">│     lru     │     │  alloc  │</span><br><span class="line">├─────────────┤     ├─────────┤</span><br><span class="line">│   refcount  │     │  flags  │</span><br><span class="line">├─────────────┤     ├─────────┤       ┌────┬────┬────┬────┬────┬─────┐</span><br><span class="line">│     ptr     ├────►│   ruf[] ├──────►│  r │ e  │ d  │ i  │ s  │  \n │</span><br><span class="line">└─────────────┘     └─────────┘       └────┴────┴────┴────┴────┴─────┘</span><br></pre></td></tr></table></figure><h3 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h3><ul><li><code>ptr</code>指向一个EMBSTR，区别在与sds的buf是指向另外一个内存地址，还是直接紧凑保存的数据</li><li>紧凑的数据结构能带来更好的处理器cache命中率（缓存局部性原理）</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│    <span class="built_in"> type </span>   │</span><br><span class="line">│  OBJ_STRING │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   encoding  │     ┌─────────┐</span><br><span class="line">│    embstr   │     │   len   │</span><br><span class="line">├─────────────┤     ├─────────┤</span><br><span class="line">│     lru     │     │  alloc  │</span><br><span class="line">├─────────────┤     ├─────────┤</span><br><span class="line">│   refcount  │     │  flags  │</span><br><span class="line">├─────────────┤     ├─────────┤</span><br><span class="line">│     ptr     ├────►│   r     │</span><br><span class="line">└─────────────┘     ├─────────┤</span><br><span class="line">                    │   e     │</span><br><span class="line">                    ├─────────┤</span><br><span class="line">                    │   d     │</span><br><span class="line">                    ├─────────┤</span><br><span class="line">                    │   i     │</span><br><span class="line">                    ├─────────┤</span><br><span class="line">                    │   s     │</span><br><span class="line">                    ├─────────┤</span><br><span class="line">                    │   \n    │</span><br><span class="line">                    └─────────┘</span><br></pre></td></tr></table></figure><h2 id="list的底层数据的演变"><a href="#list的底层数据的演变" class="headerlink" title="list的底层数据的演变"></a>list的底层数据的演变</h2><h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><ul><li>ziplist记录了总字节数，最后一个元素的偏移量，总元素个数</li><li>单个节点，保存了<strong>前一个节点的长度</strong>，当前节点的长度</li><li><strong>根据最后一个节点的偏移量，和前一个节点的长度，就能从后往前遍历</strong></li><li><strong>根据第一个节点，和当前节点的长度，就能从前往后遍历</strong></li><li>prelen长度字段编码后的，编码规则是第一个字节是否为FF来区分是1字节还是5字节</li><li>查找需要遍历，复杂度O(n)</li><li><strong>连锁更新</strong>，插入元素后，会导致prelen长度改变，有可能连锁导致所有的长度发生变化，会发生多次内存的重新分配</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="number">32</span>             <span class="number">32</span>             <span class="number">16</span>               <span class="number">8</span></span><br><span class="line">┌─────────────┬──────────────────┬─────────┬───────┬─────┐</span><br><span class="line">│             │                  │         │       │     │</span><br><span class="line">│ total <span class="keyword">bytes</span> │ <span class="keyword">last</span> <span class="keyword">item</span> <span class="built_in">offset</span> │ <span class="keyword">item</span> <span class="built_in">num</span>│       │ <span class="number">255</span> │</span><br><span class="line">└─────────────┴──────────────────┴─────────┼───────┼─────┘</span><br><span class="line">                                           │       │</span><br><span class="line">                                           │       │</span><br><span class="line">                                           │       │</span><br><span class="line">                       ┌───────────────────┘       └───────────────────┐</span><br><span class="line">                       │                                               │</span><br><span class="line">                       │                                               │</span><br><span class="line">                       ├──────┬────────┬──────┬───────┬────────┬───────┤</span><br><span class="line">                       │      │        │      │       │        │       │</span><br><span class="line">                       │prelen│encoding│ data │ prelen│encoding│ data  │</span><br><span class="line">                       └──────┴────────┴──────┴───────┴────────┴───────┘</span><br></pre></td></tr></table></figure><h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><ul><li>双向链表组织多个ziplist</li><li>让连锁更新发生在局部</li><li><strong>分片思维</strong></li><li>链表使得原本紧凑的数据结构又分散了</li></ul><h3 id="listpack（list还未采用）"><a href="#listpack（list还未采用）" class="headerlink" title="listpack（list还未采用）"></a>listpack（list还未采用）</h3><ul><li>目前底层替换的很少</li><li><strong>没有连锁更新的问题</strong><ul><li>连锁更新发生的原因？<ul><li>在ziplist中节点会引用前一个节点的长度，并且长度是编码后的，不定长，所以当前一个节点长度变更可能导致后一个节点跟着变化，</li></ul></li></ul></li><li>listpack如何解决的？<ul><li>listpack的节点不再保存前一个节点的长度，只关注自己的长度</li><li>只关注自己的长度，如何拥有往前往后遍历的能力？<ul><li>数据编码信息encoding，保存当前节点长度，并且是变长的</li><li>len字段也是变长的，</li><li>len如果第一字节的最高位为1，说明还有一个字节继续表示其长度，直到遇到的字节最高位为0为止</li></ul></li><li>从前往后遍历<ul><li>只需要根据encoding里面的长度计算偏移</li></ul></li><li>从后往前遍历<ul><li>只需要先定位到最后一个节点，根据len计算前一个节点的偏移位置</li></ul></li></ul></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬──────────┬───────┬────┐</span><br><span class="line">│             │          │       │    │</span><br><span class="line">│ total <span class="keyword">bytes</span> │ <span class="keyword">item</span> <span class="built_in">num</span> │       │ <span class="number">255</span>│</span><br><span class="line">└─────────────┴──────────┼───────┼────┘</span><br><span class="line">                         │       │</span><br><span class="line">                         │       │</span><br><span class="line">      ┌──────────────────┘       └────────┐</span><br><span class="line">      │                                   │</span><br><span class="line">      │                                   │</span><br><span class="line">      ├────────┬────┬───┬────────┬────┬───┤</span><br><span class="line">      │        │    │   │        │    │   │</span><br><span class="line">      │encoding│data│<span class="built_in">len</span>│encoding│data│<span class="built_in">len</span>│</span><br><span class="line">      └────────┴────┴───┴────────┴────┴───┘</span><br></pre></td></tr></table></figure><h2 id="set的底层实现"><a href="#set的底层实现" class="headerlink" title="set的底层实现"></a>set的底层实现</h2><h3 id="intset（整数集合）"><a href="#intset（整数集合）" class="headerlink" title="intset（整数集合）"></a>intset（整数集合）</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct <span class="built_in">int</span><span class="keyword">set</span> &#123;</span><br><span class="line">    <span class="built_in">uint</span>32_t encoding;</span><br><span class="line">    <span class="built_in">uint</span>32_t length;</span><br><span class="line">    <span class="built_in">int</span>8_t contents[];</span><br><span class="line">&#125; <span class="built_in">int</span><span class="keyword">set</span>;</span><br></pre></td></tr></table></figure><ul><li>contents 并不是表示只能保存int8，这里只是占位，实际保存的整数的长度是可变的，根据encoding决定</li><li>实际上是根据encoding计算偏移量，然后按照16位，32位或者64位来解释内存</li><li>添加删除元素都是O(N)</li><li>有序保存，所以查找是O(logN)</li></ul><h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><ul><li>拉链式解决hash冲突</li><li>渐进式rehash</li><li>负载因子，节点总数/桶的数量 &gt; 1，可以进行扩容<ul><li>rdb和aof进行的时候，会阻止扩容，因为<strong>hashtable扩容会导致大量的cow</strong></li></ul></li><li>负载因子大于5，表示需要<strong>立马扩容</strong></li><li>渐进式rehash<strong>最小单位是桶</strong></li><li><strong>防止cpu空转</strong>，会控制最大扫描的空桶个数</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                      ┌──────┐     ┌─────┐   ┌─────┐</span><br><span class="line">                ┌─────┤<span class="keyword">entry</span> ├───► │<span class="keyword">entry</span>├──►│<span class="keyword">entry</span>│</span><br><span class="line">                │     ├──────┤     └─────┘   └─────┘</span><br><span class="line">                │     │<span class="keyword">entry</span> │</span><br><span class="line">┌──────┐        │     ├──────┤</span><br><span class="line">│...   │        │     │      │</span><br><span class="line">├──────┤        │     ├──────┤</span><br><span class="line">│table0├────────┘     │      │</span><br><span class="line">├──────┤              ├──────┤</span><br><span class="line">│table1│              │      │</span><br><span class="line">├──────┤              └──────┘</span><br><span class="line">│used0 │</span><br><span class="line">├──────┤</span><br><span class="line">│used1 │</span><br><span class="line">├──────┤</span><br><span class="line">│...   │</span><br><span class="line">└──────┘</span><br></pre></td></tr></table></figure><h2 id="sortset-有序集合"><a href="#sortset-有序集合" class="headerlink" title="sortset 有序集合"></a>sortset 有序集合</h2><h3 id="skiplist-跳表"><a href="#skiplist-跳表" class="headerlink" title="skiplist 跳表"></a>skiplist 跳表</h3><ul><li>第一层就是双向链表</li><li>再对数据进行多层索引</li><li>每一层会有指向前一个节点的指针</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌─────┐</span><br><span class="line">│ L5  │</span><br><span class="line">├─────┤</span><br><span class="line">│ L4  │</span><br><span class="line">├─────┤                        <span class="number">4</span>                          ┌─────┐</span><br><span class="line">│ L3  ├──────────────────────────────────────────────────►│ L3  │</span><br><span class="line">├─────┤   <span class="number">1</span>   ┌─────┐          <span class="number">2</span>           ┌─────┐   <span class="number">1</span>    ├─────┤</span><br><span class="line">│ L2  ├──────►│ L2  ├─────────────────────►│ L2  ├───────►│ L2  │</span><br><span class="line">├─────┤   <span class="number">1</span>   ├─────┤    <span class="number">1</span>   ┌─────┐  <span class="number">1</span>    ├─────┤   <span class="number">1</span>    ├─────┤</span><br><span class="line">│ L1  ├──────►│ L1  ├───────►│ L1  ├──────►│ L1  ├───────►│ L1  │</span><br><span class="line">├─────┤       ├─────┤        ├─────┤       ├─────┤        ├─────┤</span><br><span class="line">│ BW  │◄──────┤ BW  │◄───────┤ BW  │◄──────┤ BW  │◄───────┤ BW  │</span><br><span class="line">├─────┤       ├─────┤        ├─────┤       ├─────┤        ├─────┤</span><br><span class="line">│  <span class="number">0</span>  │       │  <span class="number">1</span>  │        │  <span class="number">2</span>  │       │  <span class="number">3</span>  │        │  <span class="number">4</span>  │</span><br><span class="line">└─────┘       └─────┘        └─────┘       └─────┘        └─────┘</span><br></pre></td></tr></table></figure><h2 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h2><ul><li>近似算法，用来近似统计集合元素去重个数</li><li>N次伯努利过程</li><li>本质上就是数所有记录的key中，按位表示时连续0出现的次数，根据出现的个数可以反推出key的大概个数</li><li>有一定的误差，redis的实现误差是0.81%</li></ul><h2 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h2><ul><li>geohash算法可以对经纬度进行编码，把两个数值转换成一个，保存在zset中，相邻的数据表示地理位置更近</li><li>z字填充</li><li>有突变，查询周围八个点消除突变</li></ul><h1 id="缓存应用"><a href="#缓存应用" class="headerlink" title="缓存应用"></a>缓存应用</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><ul><li>异常<ul><li>考虑异常情况下的表现，主要是写超时的情况，无法感知到底是成功还是失败</li></ul></li><li>并发<ul><li>考虑写写，读写并发情况下的表现</li></ul></li></ul><h3 id="先写缓存，再写db-or-先写db，再写缓存"><a href="#先写缓存，再写db-or-先写db，再写缓存" class="headerlink" title="先写缓存，再写db or 先写db，再写缓存"></a>先写缓存，再写db or 先写db，再写缓存</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><pre class="mermaid">sequenceDiagram
    线程1 ->> 线程1 : 写缓存
    线程1 ->> 线程1 : 写db</pre><ul><li>无论是先写缓存还是先写db，如果其中一个写失败了，就会导致数据不一致</li></ul><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><pre class="mermaid">sequenceDiagram
    线程1 ->> 线程1 : 写缓存
    线程2 ->> 线程2 : 写缓存

    线程2 ->> 线程2 : 写db
    线程1 ->> 线程1 : 写db</pre><ul><li>最终缓存是线程2写的值，但是db是线程1的值</li></ul><pre class="mermaid">sequenceDiagram
    线程1 ->> 线程1 : 写db
    线程2 ->> 线程2 : 写db

    线程2 ->> 线程2 : 写缓存
    线程1 ->> 线程1 : 写缓存</pre><ul><li>最终缓存是线程1写的值，但是db是线程2的值</li></ul><p>可见并发情况下，无论是先写哪个最终都会导致数据不一致</p><h3 id="先删除缓存，后写db"><a href="#先删除缓存，后写db" class="headerlink" title="先删除缓存，后写db"></a>先删除缓存，后写db</h3><pre class="mermaid">sequenceDiagram
    线程1 ->> 线程1 : 删除缓存
    线程2 ->> 线程2 : 重建缓存

    线程1 ->> 线程1 : 写db</pre><ul><li>最终db是线程1的值，但是缓存是线程2读到的旧值</li></ul><h3 id="先写db，后删缓存"><a href="#先写db，后删缓存" class="headerlink" title="先写db，后删缓存"></a>先写db，后删缓存</h3><h4 id="并发下"><a href="#并发下" class="headerlink" title="并发下"></a>并发下</h4><pre class="mermaid">sequenceDiagram
    线程2 ->> 线程2 : 读取db
    线程1 ->> 线程1 : 写db    
    线程1 ->> 线程1 : 删除缓存
    线程2 ->> 线程2 : 写入缓存</pre><ul><li>极端情况下，还是会出现不一致</li><li>由于线程2读取到旧值，没有及时更新到缓存，导致最终写入缓存的还是旧值</li><li>这种情况比较极端</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul><li>key集中过期，导致请求大量穿透存储</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul><li>设置随机过期，或者不过期</li><li>预热，解决服务启动的时候，缓存大量穿透的问题</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul><li>key不存在，恶意请求导致大量请求穿透到存储</li></ul><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><ul><li>对不存在的key，也设置缓存，并且设置过期</li><li>利用布隆过滤器过滤（有一定概率）<ul><li>使用布隆过滤器，需要保存存在的key，因为布隆过滤器的特性是有可能会把不在布隆过滤器中的key判断为在里面，但是不会把存在的判断为不存在</li><li>所以有一定概率让一些不存在的key穿透到db（因为在布隆过滤器的才是存在的key，才会穿透到db）</li><li>反过来，如果保存的是不存在的key，那么可能误伤一些本来存在的，被判断为不存在的了</li></ul></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul><li>热点key过期，导致请求大量穿透到后端</li></ul><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><ul><li>读后端存储，加锁</li></ul><h1 id="redis的缓存淘汰策略"><a href="#redis的缓存淘汰策略" class="headerlink" title="redis的缓存淘汰策略"></a>redis的缓存淘汰策略</h1><ul><li>淘汰策略<ul><li>no-enviction（不进行淘汰）</li><li>需要淘汰<ul><li>volatile（在设置了过期时间的key中）<ul><li>volatile-random</li><li>volatile-ttl</li><li>volatile-lru</li><li>volatile-lfu</li></ul></li><li>allkeys（所有key中）<ul><li>allkeys-lru</li><li>allkeys-random</li><li>allkeys-lfu</li></ul></li></ul></li></ul></li></ul><h2 id="lru-least-recently-used-最近最少使用"><a href="#lru-least-recently-used-最近最少使用" class="headerlink" title="lru(least recently used)最近最少使用"></a>lru(least recently used)最近最少使用</h2><h3 id="常见实现方式"><a href="#常见实现方式" class="headerlink" title="常见实现方式"></a>常见实现方式</h3><ul><li>链表记录所有访问的key</li><li>表头是mru(最近最多使用)，表尾是lru</li><li>key被访问会被放到表头，淘汰的时候从表尾进行淘汰</li><li>由于链表操作复杂度高，因此，通常是使用<code>map+list</code>来实现</li></ul><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><ul><li>最近k次访问记录</li><li>选择最近第k次访问时间距离现在的时间为淘汰依据</li></ul><h3 id="redis中的实现"><a href="#redis中的实现" class="headerlink" title="redis中的实现"></a>redis中的实现</h3><ul><li>如果redis去维护这样的链表，那会带来很多麻烦，频繁操作链表带来额外开销</li><li>在事件循环的时候，检查是否达到内存阈值，然后选择待淘汰的key放到待淘汰的集合，进行删除，达到类似的lru效果</li><li>redisObject中有一个字段保存lur时钟，24bit</li><li>可以同步，异步淘汰</li></ul><h4 id="全局lru时钟"><a href="#全局lru时钟" class="headerlink" title="全局lru时钟"></a>全局lru时钟</h4><ul><li>精度是秒</li><li>为什么不每次都直接获取时间？<ul><li>因为获取时间的操作，是一个系统调用，内核态的切换可能影响redis的性能。这里相当于是缓存了时间</li></ul></li></ul><h2 id="lfu-最不频繁使用"><a href="#lfu-最不频繁使用" class="headerlink" title="lfu(最不频繁使用)"></a>lfu(最不频繁使用)</h2><ul><li>根据访问频次进行淘汰</li></ul><h3 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h3><ul><li>记录时间和次数（频率是一定时间内的访问次数）<ul><li>比如15分钟访问15次，和5分访问10次，虽然绝对值10次小，但是实际上5分钟的频率更高，数据更热</li></ul></li><li>复用lru的字段<ul><li>因为服务启动不同同时存在多种淘汰策略</li></ul></li><li>高16为记录时间，低7位记录次数<ul><li>时间粒度是分钟</li></ul></li><li>先衰减次数，再增加次数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>保存的并不是真正的次数，8bit最大次数才255，显然不够用</li><li>因此保存的是概率性的次数，越大越难涨，难易程度是可配置的</li></ul><h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><ul><li>lru和lfu在删除key的时候都是可以配置是否启用惰性删除的</li><li>针对一些大key的场景，同步删除可能导致redis突然延时增加，影响其他客户端</li></ul><h3 id="启用惰性删除的场景配置"><a href="#启用惰性删除的场景配置" class="headerlink" title="启用惰性删除的场景配置"></a>启用惰性删除的场景配置</h3><table><thead><tr><th>场景</th><th>配置</th></tr></thead><tbody><tr><td>缓存淘汰时的数据删除场景</td><td>lazyfree-lazy-evictio</td></tr><tr><td>过期 key 的删除场景</td><td>lazyfree-lazy-expire</td></tr><tr><td>隐式进行删除操作的 server 命令执行场景</td><td>lazyfree-lazy-server-del</td></tr><tr><td>从节点完成全量同步后，删除原有旧数据的场景</td><td>replica-lazy-flush</td></tr></tbody></table><h3 id="惰性删除流程"><a href="#惰性删除流程" class="headerlink" title="惰性删除流程"></a>惰性删除流程</h3><p>删除操作</p><ul><li>全局dict表删除key</li><li>释放空间（同步或者异步）</li><li>不同对象，有不同的删除代价，list，set，zset，hash的成员数量就是删除的的代价</li><li>内存紧凑的对象，直接释放空间代价并不高</li><li>后台线程和主线程使用条件变量和互斥锁实现同步</li></ul><h1 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h1><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li>事件反应堆<ul><li>fd读写回调的时候，会再次产生读写事件，把读写事件继续加入事件循环器，这样就形成事件反应堆了</li></ul></li><li>优先使用epoll</li><li>单线程也能处理多fd</li><li>select监听fd数量有限，需要轮询fd</li><li>poll也需要轮询fd</li><li>epoll，不需要轮询，效率更高</li><li>一般还要把fd设置为非阻塞的，这样read，write不会阻塞</li><li>单线程，实现简单，操作数据不需要加锁，cpu不是redis的瓶颈<ul><li>所以大key对redis的影响很大，会阻塞其他客户端</li></ul></li><li>耗时操作会使用其他线程，比如惰性删除的释放内存，aof刷盘等</li></ul><h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h3><ul><li>accept，read，write，处理业务逻辑都在<strong>一个线程</strong></li><li><strong>缺点</strong><ul><li>redis6.0都是这种模型，缺点是<strong>无法利用多核</strong>提高效率</li><li>单个事件的处理，可能影响其他请求</li><li>并发请求，read和write可能出现瓶颈</li><li>redis6.0后，采用的是读写fd用线程池（不是一定用，看配置和其他条件），处理业务逻辑还是单线程，因为是内存操作，这里单线程也不会是瓶颈，而且单线程减少了锁的使用</li></ul></li></ul><h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><ul><li>accept，read，write 在一个线程</li><li>业务处理在线程池</li></ul><h3 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a>主从Reactor多线程模型</h3><ul><li>主Reactor处理监听套接字，负责和客户端建立连接，然后把连接套接字给从Reactor处理</li><li>从Reactor和客户端进行读写，处理业务逻辑，通常从Reactor和cpu个数相等</li><li>Nginx的实现就是这样，不过nginx的slave进程都是可以进程accept的</li></ul><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><ul><li>和客户端的连接事件，读写事件</li><li>每次写fd，如果大于NET_MAX_WRITES_PER_EVENT（64k），会分成多次写，这样不会因为单次写耗时太大，从节点除外</li></ul><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><ul><li>定时任务</li><li>redis这里实现是链表，正常应该是堆或者红黑树来实现，因为redis这里只有<strong>2个</strong>时间事件</li><li>事件循环wait的时间就是最近的时间事件到来的时间，这样每次事件循环阻塞结束后，如果没有网络请求，可以找到时间事件来执行，常见的定时器调度也是这样实现的</li></ul><h2 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h2><h3 id="三个后台线程"><a href="#三个后台线程" class="headerlink" title="三个后台线程"></a>三个后台线程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_CLOSE_FILE    0 <span class="comment">/* Deferred close(2) syscall.  close客户端连接*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_AOF_FSYNC     1 <span class="comment">/* Deferred AOF fsync. 后台刷aof*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_LAZY_FREE     2 <span class="comment">/* Deferred objects freeing. 惰性删除*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_t</span> bio_threads[BIO_NUM_OPS];<span class="comment">// 线程描述符</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> bio_mutex[BIO_NUM_OPS];<span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> bio_newjob_cond[BIO_NUM_OPS];<span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">list</span> *bio_jobs[BIO_NUM_OPS]; <span class="comment">// 任务</span></span><br></pre></td></tr></table></figure><ul><li>互斥锁和条件变量实现的<strong>生产者-消费者模型</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioSubmitJob</span><span class="params">(<span class="keyword">int</span> type, bio_job *job)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre class="mermaid">sequenceDiagram
    线程1 ->> 线程1 : pthread_mutex_lock
    线程1 ->> 线程1 : pthread_cond_wait，unlock，等待，lock
    线程1 ->> 线程1 : 消费任务
    线程1 ->> 线程1 : pthread_mutex_unlock

    线程2 ->> 线程2 : pthread_mutex_lock
    线程2 ->> 线程2 : 生产任务
    线程2 ->> 线程2 : pthread_mutex_unlock
    线程2 ->> 线程2 : pthread_cond_signal</pre><h3 id="io线程池"><a href="#io线程池" class="headerlink" title="io线程池"></a>io线程池</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> io_threads[IO_THREADS_MAX_NUM];<span class="comment">// io线程描述符</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> io_threads_mutex[IO_THREADS_MAX_NUM]; <span class="comment">// 互斥锁，主线程通过这个控制io线程阻塞</span></span><br><span class="line">threads_pending io_threads_pending[IO_THREADS_MAX_NUM]; <span class="comment">// 线程的任务数</span></span><br><span class="line"><span class="keyword">int</span> io_threads_op;      <span class="comment">// 读写空闲标记，这个变量只在主线程会修改，不需要使用原子的</span></span><br></pre></td></tr></table></figure><ul><li>io线程数量大于1的时候开启</li><li>初始化后没有立马启用</li><li>使用原子变量进行同步</li><li><code>io_threads_mutex</code> 用于主线程控制暂停线程池（<strong>防止空闲时空转</strong>）</li></ul><h4 id="io线程池读"><a href="#io线程池读" class="headerlink" title="io线程池读"></a>io线程池<strong>读</strong></h4><ul><li>默认不开启，需要配置文件显示指定</li><li>io线程的读和普通直接读都是同一个回调函数<code>readQueryFromClient</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">postponeClientRead</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.io_threads_active &amp;&amp; <span class="comment">// io线程开启（启动不等于开启）</span></span><br><span class="line">        server.io_threads_do_reads &amp;&amp; <span class="comment">// 读操作开启使用io线程池</span></span><br><span class="line">        !ProcessingEventsWhileBlocked &amp;&amp; <span class="comment">// processEventsWhileBlocked 没有执行</span></span><br><span class="line">        !(c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_BLOCKED)) &amp;&amp; <span class="comment">// master，slave，已经阻塞的客户端不使用</span></span><br><span class="line">        io_threads_op == IO_THREADS_OP_IDLE)  <span class="comment">// io线程池空闲</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有设置单个客户端的状态了，直接根据io_threads_op判断</span></span><br><span class="line">        listAddNodeHead(server.clients_pending_read,c);</span><br><span class="line">        c-&gt;pending_read_list_node = listFirst(server.clients_pending_read);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>readQueryFromClient</code>会将阻塞客户端添加任务到阻塞，读事件的回调</li><li>事件循环wait前，都会检查<code>clients_pending_read</code>是否需要用io线程读</li><li><strong>主线程也会参与io读</strong></li><li>主线程把自己任务处理完后，会等待io线程结束，使用<strong>原子变量</strong>看任务是否已经处理完</li><li>读取完成后，主线程进行命令的执行</li><li>每次最大读16M数据，epoll默认采用水平触发（有未消费的数据就会触发epoll_wait返回），redis采用的水平触发</li></ul><h4 id="io线程池写"><a href="#io线程池写" class="headerlink" title="io线程池写"></a>io线程池<strong>写</strong></h4><ul><li>事件循环wait前，会检查写的阻塞链表```clients_pending_write``是否有数据，有的话就进行处理，和读的类似</li><li>写操作如果回包过大，会暂时break写操作，下次事件循环仔写，这样不会阻塞其他客户端，比如执行<code>keys *</code>的这种操作<ul><li><code>keys *</code>这种回包大的处理的流程是，先把key都读到一个缓存链表中（每个16k），再使用io线程在多个事件循环中分批回给客户端</li><li>在处理的流程中，读所有的key是阻塞的，可能影响整个server</li></ul></li></ul><h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><h2 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h2><ul><li>二进制数据</li><li>fork子进程写入（COW）<ul><li>fork是阻塞的系统调用，可能 会给系统带来阻塞</li></ul></li></ul><h3 id="生成的时机"><a href="#生成的时机" class="headerlink" title="生成的时机"></a>生成的时机</h3><ul><li>手动触发<ul><li>save命令</li><li>bgsave命令</li></ul></li><li>被动触发<ul><li>主从复制（不会生成文件，直接传输到socket）</li></ul></li><li>定时触发<ul><li>serverCron执行频率自动检查触发</li></ul></li><li>flushall</li><li>关闭server</li></ul><h2 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h2><ul><li>记录逻辑操作</li><li>追加写</li><li>策略<ul><li>always：每次都写，最多丢失一个事件循环的数据<ul><li>因为redis的aof刷盘是在beforSleep中执行的，是下一次事件循环的开始，所以此时，上一次的aof是还没有fsync的，如果此时重启，会丢失一个事件循环的操作</li><li>和mysql不同的是，mysql是WAL(Write-Ahead Logging)，并且通过两阶段提交，来保证了事务不丢失</li></ul></li><li>everyec：每秒执行</li><li>no：操作系统自动刷盘</li></ul></li></ul><h3 id="aof重写"><a href="#aof重写" class="headerlink" title="aof重写"></a>aof重写</h3><ul><li>防止aof文件过大，因为是记录的操作，aof重写可以把多个操作合并为一个</li><li>aof重写有一个标记<code>aof_rewrite_scheduled</code>，用来防止重入</li><li>全量+增量</li></ul><h3 id="aof重写演进"><a href="#aof重写演进" class="headerlink" title="aof重写演进"></a>aof重写演进</h3><h4 id="redis2-8以及以前"><a href="#redis2-8以及以前" class="headerlink" title="redis2.8以及以前"></a>redis2.8以及以前</h4><pre class="mermaid">sequenceDiagram
    父进程 ->> 子进程 : fork
    子进程 ->> 子进程 : 写全量数据
    父进程 ->> 父进程 : 暂存增量命令到aof buffer（老aof文件使用）和rewrite buffer（新aof使用）
    子进程 ->> 子进程 : 全量数据写结束
    父进程 ->> 父进程 : 把aof buffer一次性写到aof文件（可能阻塞）</pre><ul><li>一次性写buffer到磁盘会导致redis阻塞</li></ul><h4 id="redis3-0"><a href="#redis3-0" class="headerlink" title="redis3.0"></a>redis3.0</h4><pre class="mermaid">sequenceDiagram
    父进程 ->> 子进程 : fork
    子进程 ->> 子进程 : 写全量数据
    父进程 ->> 父进程 : 暂存增量命令到aof buffer和rewrite buffer
    父进程 ->> 子进程 : 通过管道把rewrite buffer发送给子进程
    子进程 ->> 子进程 : 全量数据写结束</pre><ul><li>同一份数据需要写两份buffer</li><li>需要使用6个管道进行通信</li></ul><h4 id="redis7-0的multi-part-aof"><a href="#redis7-0的multi-part-aof" class="headerlink" title="redis7.0的multi part aof"></a>redis7.0的multi part aof</h4><pre class="mermaid">sequenceDiagram
    父进程 ->> 子进程 : fork
    子进程 ->> 子进程 : 写全量数据到base.rdb（混合持久化）
    父进程 ->> 父进程 : 暂存增量命令到aof buffer
    父进程 ->> 父进程 : 把aof buffer写到incr.aof
    子进程 ->> 子进程 : 全量数据写结束
    父进程 ->> 父进程 : 把base和incr合并成mainfest目录，mainfest目录中老的记录标记为history，后续清理</pre><ul><li>aof文件由全量数据文件+增量文件构成</li><li>base.rdb是rdb文件，这样空间更小（混合持久化）</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ul><li>全量同步</li><li>命令传播<ul><li>推拉结合，master会主动把命令传播给slave，slave也会定时拉取</li><li>master不会等到slave写入成功，就返回客户端<h3 id="演进过程"><a href="#演进过程" class="headerlink" title="演进过程"></a>演进过程</h3></li></ul></li></ul><h4 id="redis2-8以前"><a href="#redis2-8以前" class="headerlink" title="redis2.8以前"></a>redis2.8以前</h4><pre class="mermaid">sequenceDiagram
    slave ->> master : sync
    master ->> master : fork生成快照
    master ->> slave : 发送快照
    master ->> master : 暂存增量命令
    master ->> slave : 发送缓存命令
    master ->> slave : 命令传播</pre><ul><li>slave断开连接重新连接需要再次全量同步</li></ul><h4 id="redis2-8"><a href="#redis2-8" class="headerlink" title="redis2.8"></a>redis2.8</h4><pre class="mermaid">graph TB
    start[开始] --> isFirst{是否首次复制}  
    isFirst -- Yes --> psyncAll[PSYNC ? -1]
    isFirst -- No --> psyncPart[PSYNC master offset]
    psyncPart --> isOk{主节点检查}
    isOk -- Yes --> run[执行部分同步]
    isOk -- No --> runAll[执行全量同步]
    psyncAll --> runAll[执行全量同步]</pre><ul><li>需要从节点记录master的信息，但是重启也会丢失</li><li>如果offset不在master的缓存中，那么只能进行全量同步</li><li>如果master发生主从切换，新主id不同，那么所有的slave都要重新全量同步</li></ul><h4 id="redis4-0"><a href="#redis4-0" class="headerlink" title="redis4.0"></a>redis4.0</h4><ul><li>引入replid，相当于之前依赖master的runid，现在依赖replid</li><li>主从断开的时间是有限的，取决于backlog的大小，如果offset不在buffer中，只能全量同步</li></ul><h4 id="redis7-0（百度贡献）"><a href="#redis7-0（百度贡献）" class="headerlink" title="redis7.0（百度贡献）"></a>redis7.0（百度贡献）</h4><ul><li>共享复制缓冲区<ul><li>从库的复制缓冲区从私有变为共享，多个slave共享buffer，通过引用计数来组织</li><li>链表把所有的buffer串起来，如果引用计数为0，就释放</li></ul></li></ul><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>监控主从节点</li><li>故障转移（automatic failover）</li><li>配置提供（客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址）</li><li>通知（哨兵可以将故障转移的结果发送给客户端）</li></ul><h3 id="哨兵集群的发现和建立"><a href="#哨兵集群的发现和建立" class="headerlink" title="哨兵集群的发现和建立"></a>哨兵集群的发现和建立</h3><ul><li>master节点会有一个```<strong>sentinel</strong>:hello``的频道，哨兵通过订阅发布进行感知</li><li>哨兵通过info命令感知从库</li></ul><h3 id="感知节点故障"><a href="#感知节点故障" class="headerlink" title="感知节点故障"></a>感知节点故障</h3><ul><li><strong>主观下线</strong>：哨兵通过自己和节点的链接，主观判断节点是否下线（可能误判）</li><li><strong>客观下线</strong>：配置数量的哨兵共同判断节点下线，则为客观下线</li></ul><h3 id="故障切换"><a href="#故障切换" class="headerlink" title="故障切换"></a>故障切换</h3><ul><li>哨兵选举领导者（raft选举，超半数同意，成为leader）</li><li>由领导者发起故障转移，进行主从切换</li><li>选择新主<ul><li>过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点</li><li>选择salve-priority从节点优先级最高（redis.conf）的</li><li>选择复制偏移量最大，只复制最完整的从节点</li></ul></li><li>把其中一个升级为master</li><li>让其他节点成为新主的从节点</li><li>通知客户端新主</li><li><strong>主从切换期间，可能有命令还没同步到从库，导致从库的数据慢于主库，此时切换后回出现丢数据的情况</strong></li></ul><h1 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h1><h2 id="cas"><a href="#cas" class="headerlink" title="cas"></a>cas</h2><ul><li><code>cas set</code>,带版本号的set</li><li>利用lua实现，保证原子，可以把版本号拼接在数据的前面，这样只需要一个key就能保存数据和版本号</li><li>在lua中使用<code>struct.unpack</code>可以解出版本号，进行判断</li></ul><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div><div><div id="wechat_subscriber" style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id="wechat_subscriber_qcode" src="/images/wechat.jpg" alt="codelover wechat" style="width:200px;max-width:100%"><div>原创公众号</div></div></div><div><style>#rewardButton span{display:inline-block;width:80px;height:35px;border-radius:5px;color:#fff;font-weight:400;font-style:normal;font-variant:normal;font-stretch:normal;font-size:18px;font-family:"Microsoft Yahei";background:#f44336}#rewardButton{cursor:pointer;border:0;outline:0;border-radius:100%;padding:0;margin:0;letter-spacing:normal;text-transform:none;text-indent:0;text-shadow:none}</style><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'><span>赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" width="50%" height="50%" src="/images/reward.jpg" alt="codelover 微信支付"><p>微信支付</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/redis%E5%AE%9E%E7%8E%B0/" rel="tag"><i class="fa fa-tag"></i> redis实现</a> <a href="/tags/listpack/" rel="tag"><i class="fa fa-tag"></i> listpack</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"><i class="fa fa-tag"></i> 线程池</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 多线程</a> <a href="/tags/%E5%8F%AF%E9%9D%A0%E6%80%A7/" rel="tag"><i class="fa fa-tag"></i> 可靠性</a> <a href="/tags/%E4%B8%BB%E4%BB%8E/" rel="tag"><i class="fa fa-tag"></i> 主从</a> <a href="/tags/%E5%93%A8%E5%85%B5/" rel="tag"><i class="fa fa-tag"></i> 哨兵</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/epoll/" rel="next" title="epoll的原理和应用"><i class="fa fa-chevron-left"></i> epoll的原理和应用</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-----若有不妥，敬请斧正-----</div></div></div></article><script type="application/ld+json">{
    "@context": "https://schema.org/",
    "@type": "BlogPosting",
    "@id": "https://codeloverme.cn/redis-new/",
    "headline": "redis详解",
    "name": "redis详解",
    "description": "",
    "datePublished": "2023-02-16T22:34:19+08:00",
    "dateModified": "2023-02-16T22:34:19+08:00",
    "author": {
        "@type": "Person",
        "@id": "https://codeloverme.cn",
        "name": "codelover",
        "url": "https://codeloverme.cn",
        "image": {
        }
    },
    "url": "https://codeloverme.cn/redis-new/",
    "commentCount": "0",
    "comment": [
    ],
    "about": [ 

    ],
    "wordCount": "",
    "keywords": [
    ]
}</script><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/logo.png" alt="codelover"><p class="site-author-name" itemprop="name">codelover</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">文章</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/lovercode" target="_blank" rel="external nofollow noopener noreferrer" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:qiuleilove@gmail.com" target="_blank" rel="external nofollow noopener noreferrer" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据结构"><span class="nav-number">1.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#支持的数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">支持的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的三种编码方式"><span class="nav-number">1.2.</span> <span class="nav-text">string的三种编码方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#int"><span class="nav-number">1.2.1.</span> <span class="nav-text">int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#raw"><span class="nav-number">1.2.2.</span> <span class="nav-text">raw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#embstr"><span class="nav-number">1.2.3.</span> <span class="nav-text">embstr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list的底层数据的演变"><span class="nav-number">1.3.</span> <span class="nav-text">list的底层数据的演变</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ziplist"><span class="nav-number">1.3.1.</span> <span class="nav-text">ziplist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quicklist"><span class="nav-number">1.3.2.</span> <span class="nav-text">quicklist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listpack（list还未采用）"><span class="nav-number">1.3.3.</span> <span class="nav-text">listpack（list还未采用）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set的底层实现"><span class="nav-number">1.4.</span> <span class="nav-text">set的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#intset（整数集合）"><span class="nav-number">1.4.1.</span> <span class="nav-text">intset（整数集合）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable"><span class="nav-number">1.4.2.</span> <span class="nav-text">hashtable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sortset-有序集合"><span class="nav-number">1.5.</span> <span class="nav-text">sortset 有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#skiplist-跳表"><span class="nav-number">1.5.1.</span> <span class="nav-text">skiplist 跳表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hyperloglog"><span class="nav-number">1.6.</span> <span class="nav-text">hyperloglog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#geo"><span class="nav-number">1.7.</span> <span class="nav-text">geo</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缓存应用"><span class="nav-number">2.</span> <span class="nav-text">缓存应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存一致性"><span class="nav-number">2.1.</span> <span class="nav-text">缓存一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先写缓存，再写db-or-先写db，再写缓存"><span class="nav-number">2.1.1.</span> <span class="nav-text">先写缓存，再写db or 先写db，再写缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">并发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先删除缓存，后写db"><span class="nav-number">2.1.2.</span> <span class="nav-text">先删除缓存，后写db</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先写db，后删缓存"><span class="nav-number">2.1.3.</span> <span class="nav-text">先写db，后删缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发下"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">并发下</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">2.2.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决"><span class="nav-number">2.2.1.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存穿透"><span class="nav-number">2.3.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存击穿"><span class="nav-number">2.4.</span> <span class="nav-text">缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis的缓存淘汰策略"><span class="nav-number">3.</span> <span class="nav-text">redis的缓存淘汰策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lru-least-recently-used-最近最少使用"><span class="nav-number">3.1.</span> <span class="nav-text">lru(least recently used)最近最少使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见实现方式"><span class="nav-number">3.1.1.</span> <span class="nav-text">常见实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU-K"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">LRU-K</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis中的实现"><span class="nav-number">3.1.2.</span> <span class="nav-text">redis中的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局lru时钟"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">全局lru时钟</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lfu-最不频繁使用"><span class="nav-number">3.2.</span> <span class="nav-text">lfu(最不频繁使用)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis实现"><span class="nav-number">3.2.1.</span> <span class="nav-text">redis实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惰性删除"><span class="nav-number">3.3.</span> <span class="nav-text">惰性删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用惰性删除的场景配置"><span class="nav-number">3.3.1.</span> <span class="nav-text">启用惰性删除的场景配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性删除流程"><span class="nav-number">3.3.2.</span> <span class="nav-text">惰性删除流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis为什么这么快"><span class="nav-number">4.</span> <span class="nav-text">redis为什么这么快</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件循环"><span class="nav-number">4.1.</span> <span class="nav-text">事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单-Reactor-单线程"><span class="nav-number">4.1.1.</span> <span class="nav-text">单 Reactor 单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单-Reactor-多线程"><span class="nav-number">4.1.2.</span> <span class="nav-text">单 Reactor 多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从Reactor多线程模型"><span class="nav-number">4.1.3.</span> <span class="nav-text">主从Reactor多线程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件类型"><span class="nav-number">4.2.</span> <span class="nav-text">事件类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件事件"><span class="nav-number">4.2.1.</span> <span class="nav-text">文件事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间事件"><span class="nav-number">4.2.2.</span> <span class="nav-text">时间事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis线程模型"><span class="nav-number">4.3.</span> <span class="nav-text">redis线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三个后台线程"><span class="nav-number">4.3.1.</span> <span class="nav-text">三个后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io线程池"><span class="nav-number">4.3.2.</span> <span class="nav-text">io线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#io线程池读"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">io线程池读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#io线程池写"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">io线程池写</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可靠性"><span class="nav-number">5.</span> <span class="nav-text">可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rdb"><span class="nav-number">5.1.</span> <span class="nav-text">rdb</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成的时机"><span class="nav-number">5.1.1.</span> <span class="nav-text">生成的时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aof"><span class="nav-number">5.2.</span> <span class="nav-text">aof</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aof重写"><span class="nav-number">5.2.1.</span> <span class="nav-text">aof重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof重写演进"><span class="nav-number">5.2.2.</span> <span class="nav-text">aof重写演进</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis2-8以及以前"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">redis2.8以及以前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis3-0"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">redis3.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis7-0的multi-part-aof"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">redis7.0的multi part aof</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主从复制"><span class="nav-number">5.3.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#演进过程"><span class="nav-number">5.3.1.</span> <span class="nav-text">演进过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis2-8以前"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">redis2.8以前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis2-8"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">redis2.8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis4-0"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">redis4.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis7-0（百度贡献）"><span class="nav-number">5.3.1.4.</span> <span class="nav-text">redis7.0（百度贡献）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哨兵机制"><span class="nav-number">5.4.</span> <span class="nav-text">哨兵机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#目的"><span class="nav-number">5.4.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哨兵集群的发现和建立"><span class="nav-number">5.4.2.</span> <span class="nav-text">哨兵集群的发现和建立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#感知节点故障"><span class="nav-number">5.4.3.</span> <span class="nav-text">感知节点故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障切换"><span class="nav-number">5.4.4.</span> <span class="nav-text">故障切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见使用场景"><span class="nav-number">6.</span> <span class="nav-text">常见使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cas"><span class="nav-number">6.1.</span> <span class="nav-text">cas</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#QA"><span class="nav-number">7.</span> <span class="nav-text">QA</span></a></li></ol></div></div></section><div id="aplayer-hjnObCgk" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="4933107776" data-server="netease" data-type="playlist" data-order="random" data-lrctype="false" data-listfolded="true" data-fixed="false" data-autoplay="false" data-volume="0.4" data-mutex="true" data-listmaxheight="200px" data-preload="none" data-theme="#00b9f1"></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">codelover</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Site words total count&#58;</span> <span title="Site words total count">14.6k</span></div><div class="footer-custom"><a target="_blank" href="https://beian.miit.gov.cn" target="_blank" rel="external nofollow noopener noreferrer">粤ICP备2022058819号</a></div><script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script><script>window.mermaid&&mermaid.initialize("")</script><div class="busuanzi-count"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><script type="text/javascript">!function(){var e=document.createElement("script");e.src="//tajs.qq.com/stats?sId=66533329";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")};function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var searchFunc=function(t,s,a){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");function e(){var m=n.value.trim().toLowerCase(),x=m.split(/[\s\-]+/);1<x.length&&x.push(m);var e,w=[];0<m.length&&o.forEach(function(t){var e=!1,o=0,h=0,n=t.title.trim(),r=n.toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,""),a=s.toLowerCase(),i=decodeURIComponent(t.url),c=[],l=[];if(""!=n&&(x.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r,s=0,a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());-1<(r=e.indexOf(t,s));)a.push({position:r,word:t}),s=r+n;return a}c=c.concat(e(t,r,!1)),l=l.concat(e(t,a,!1))}),(0<c.length||0<l.length)&&(e=!0,o=c.length+l.length)),e){function p(t,e,o,n){for(var r=n[n.length-1],s=r.position,a=r.word,i=[],c=0;s+a.length<=o&&0!=n.length;){a===m&&c++,i.push({position:s,length:a.length});var l=s+a.length;for(n.pop();0!=n.length&&(s=(r=n[n.length-1]).position,a=r.word,s<l);)n.pop()}return h+=c,{hits:i,start:e,end:o,searchTextCount:c}}[c,l].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});t=[];0!=c.length&&t.push(p(0,0,n.length,c));for(var u=[];0!=l.length;){var f=l[l.length-1],d=f.position,g=f.word,v=d-20,f=d+80;v<0&&(v=0),(f=f<d+g.length?d+g.length:f)>s.length&&(f=s.length),u.push(p(0,v,f,l))}u.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});e=parseInt("1");function $(o,t){var n="",r=t.start;return t.hits.forEach(function(t){n+=o.substring(r,t.position);var e=t.position+t.length;n+='<b class="search-keyword">'+o.substring(t.position,e)+"</b>",r=e}),n+=o.substring(r,t.end)}0<=e&&(u=u.slice(0,e));var C="";0!=t.length?C+="<li><a href='"+i+"' class='search-result-title'>"+$(n,t[0])+"</a>":C+="<li><a href='"+i+"' class='search-result-title'>"+n+"</a>",u.forEach(function(t){C+="<a href='"+i+'\'><p class="search-result">'+$(s,t)+"...</p></a>"}),C+="</li>",w.push({item:C,searchTextCount:h,hitCount:o,id:w.length})}}),1===x.length&&""===x[0]?r.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>':0===w.length?r.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>':(w.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id}),e='<ul class="search-result-list">',w.forEach(function(t){e+=t.item}),e+="</ul>",r.innerHTML=e)}var o=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,n=document.getElementById(s),r=document.getElementById(a);n.addEventListener("input",e),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/hijiki.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body><script defer src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5565422729000416" crossorigin="anonymous"></script></html>